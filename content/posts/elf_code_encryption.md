---
title: "ELF code encryption [draft]"
author: "Filippo Ziche"
description: "In this post we will learn how to dynamically encrypt/decrypt code sections of an ELF file to make reverse engineering a bit more difficult."
date: 2022-10-21
draft: false
---

# Motivation 

Dynamic encryption and decryption of executable code is an usefull and interesting thing, it can be used to protect our software from reverse engineering attempts or to create polymorphic viruses that hide their code signature from simple antivirus signature detection. In this post we will focus our attention on the first case, hiding our closed source code and exposing only a "loader" interface, used to decrypt the code after, for example, we pass a signature check.

# ELF file format

The ELF file is used to describe how a program is laid out in main memory, and is made of a header, describing the internal structure of the file, and some sections and segments. To keep things simple and not 
delve to deep in the format internals (you can find all the information here: https://man7.org/linux/man-pages/man5/elf.5.html) we just need to remember that the code and static data of a program are stored inside different sections, .text for the instructions, .data and .bss for static initialized and uninitialized variables respectively. Segments describe how different multiple sections are laid out in virtual memory. 

```c
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000333  00000000  00000000  00000040  2**4
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000050  00000000  00000000  00000380  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003d0  2**2
                  ALLOC
  3 .note         00000014  00000000  00000000  000003d0  2**0
                  CONTENTS, READONLY
  4 .stab         000020e8  00000000  00000000  000003e4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .stabstr      00008f17  00000000  00000000  000024cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .rodata       000001e4  00000000  00000000  0000b400  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .comment      00000023  00000000  00000000  0000b5e4  2**0
                  CONTENTS, READONLY
```

Here we can see the standard sections of an EFL file.

# Encrypted section

Our goal is to add a new custom section, .etext, to the ELF and to place all our hidden code inside it. Thankfully this is simple using gcc, we just have to add a function attribute to all functions we want to protect and the compiler will automatically add them to che specified section. To make things more readable we will use a macro.

```c
#define ENCRYPTED_SECTION ".etext"
#define ENCRYPTED __attribute__ ((__section__ (POLYV_ENCRYPTED_SECTION)))
```

Now we can put any function in the .etext section easily.

```c
void ENCRYPTED encrypted_function() { /* ... */ }
void normal_function() { /* ... */ }
```

But there are problems, big ones. This only works on if there is only a single compilation unit, a single .cpp file. That is a bit limiting, we shouldn't be forced to develop our application as a unity build!
And if we manage to merge all .etext of our units into a final big one, where is it in memory? How can we find it? To answer all those question we will use an old art, known only to embedded firmware developers, a custom linker script.

```

// With the SECTIONS comands we can specify how the sections of the different
// object files are merged together, here we simply merge all separate .etext sections
SECTIONS {

	// The OVERLAY command is exactly what we need to manipulate the hidden section, 
	// it will create two linker symbols, one at the beginning and one at the end  
    	OVERLAY : { .etext { *(.etext) } }

	// This is the section that will contain our program license
    	.license : { *(.license) }

} INSERT AFTER .text;
```

If we call this linker script _encrypted.ld_ then we can use it during compilation by using the linker flag -T.

```bash
ld -Tencrypted.ld ...
```

# Loader

With our setup complete we can now create the loader, which will encrypt/decrypt our hidden section using a simple XOR with the license.

```c
// The linker sections generated by the OVERLAY command in the linker script
extern char __load_start_etext, __load_stop_etext;

void self_sxor(char* key, size_t key_size) {

    size_t section_beg = (size_t)&__load_start_etext;
    size_t section_end = (size_t)&__load_stop_etext;

    const size_t page_size = getpagesize();
    const size_t section_delta = section_end - section_beg;
    size_t section_size = section_delta;

    if (section_size % page_size != 0)
        section_size = section_delta + (section_delta % page_size);

    // Enable writing of the section
    void* section_page = (void*)(section_beg - (section_beg % page_size));
    mprotect(section_page, section_size, PROT_EXEC | PROT_WRITE | PROT_READ);

    // Apply symmetric XOR with provided key
    char* section = (char*)(section_beg);
    polyv_sxor(section, section_delta, key, key_size);

    // Disable writing of the section
    mprotect(section_page, section_size, PROT_EXEC | PROT_READ);
}
```
# Conclusion

Thanks! Until next time.
FZ.

